name: Update Projects Data

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  schedule:
    # Run daily at midnight UTC to keep projects updated
    - cron: '0 0 * * *'

jobs:
  update-projects:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Fetch repositories from GitHub API
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PAT_TOKEN: ${{ secrets.GH_PAT_TOKEN }}
        IO_TOKEN: ${{ secrets.IO }}
      run: |
        # Priority: IO secret > GH_PAT_TOKEN secret > GITHUB_TOKEN
        if [ -n "$IO_TOKEN" ]; then
          echo "Using IO secret for repository access"
          TOKEN=$IO_TOKEN
        elif [ -n "$PAT_TOKEN" ]; then
          echo "Using GH_PAT_TOKEN secret for repository access"
          TOKEN=$PAT_TOKEN
        else
          echo "Warning: No token secret found. Using GITHUB_TOKEN (may not have access to private repos)"
          TOKEN=$GITHUB_TOKEN
        fi
        
        # Fetch all repositories
        echo "Fetching repositories from GitHub API..."
        curl -H "Authorization: token $TOKEN" \
             -H "Accept: application/vnd.github.v3+json" \
             "https://api.github.com/user/repos?type=all&per_page=100&sort=updated&direction=desc" \
             > repos_raw.json
        
        # Check if API call was successful
        if [ ! -s repos_raw.json ]; then
          echo "Error: Failed to fetch repositories"
          exit 1
        fi
        
        # Check for API errors in response
        if grep -q '"message"' repos_raw.json; then
          echo "Error: GitHub API returned an error:"
          cat repos_raw.json
          exit 1
        fi
        
        # Process repositories using Node.js
        node << 'EOF'
        const fs = require('fs');
        
        const repos = JSON.parse(fs.readFileSync('repos_raw.json', 'utf8'));
        
        // Configuration (matches config.js options)
        const excludeForks = true;
        const excludeArchived = true;
        const excludePrivate = false;
        
        // List of repository names to exclude from the portfolio (case-insensitive)
        // Add repository names here that you don't want to display
        const excludeRepos = [
          'FSRA',
          'Som WorkAssist',
          'SidharthRao.github.io',
          'Important Scripts Practice',
          'National Statistics Automation',
          'Project Rogue',
          'CAO PowerBI Project',
          'GenAI CustomerServiceBot',
          'ExecutorAssist And ImportantScript',
          'ExpenseAccrual',
          'MSDS Projects And Concepts',
          'Automation Treasury',
          'EndToEnd VendorWHTActivity',
          'Vendor WHT',
          'RCM InvoiceGeneration',
          'TimeSeries SpecializedModels',
          'AuditAssistant ChatBot',
          'Model Fine Tuning',
          'Project Dash',
          'Custom Voicebot',
          'S4 HanaRecon',
          'ML-Applicability-POC-Projects',
          'Text_Analysis-Reclass',
          'IC_Revenue',
          'IC_Automation',
          'Finalyzer_DataIngestion2.0',
          'Expense_Classification-and-Reclass',
          'KPI-Dashboad',
          'AAAMLP GuideForProjectFolders',
          'Arithmetic_Algo',
          'Base_ML-Scripts',
          'Natural-Language-Processing',
          'Intel-AI---MLOps',
          'Flask_Basics',
          'StockMarketAalysis',
          'ICA WHT Reporting',
          'expense_reclassification',
          'Applying-feature-selection',
          
          // Add more repository names here, e.g.:
          // 'another-repo-name',
          // 'yet-another-repo'
        ];
        
        // Helper function to format project names (used for exclusion matching)
        function formatProjectName(name) {
          return name
            .split(/[-_]/)
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
        }
        
        // Filter repositories
        const filtered = repos.filter(repo => {
          if (excludeForks && repo.fork) return false;
          if (excludeArchived && repo.archived) return false;
          if (excludePrivate && repo.private) return false;
          // Exclude specific repositories by name (case-insensitive)
          // Check both original name and formatted name to handle exclusion list flexibility
          const repoNameLower = repo.name.toLowerCase();
          const formattedNameLower = formatProjectName(repo.name).toLowerCase();
          if (excludeRepos.some(excluded => {
            const excludedLower = excluded.toLowerCase();
            return repoNameLower === excludedLower || formattedNameLower === excludedLower;
          })) {
            return false;
          }
          return true;
        });
        
        // Load custom project configurations
        let projectConfigs = {};
        try {
          if (fs.existsSync('config/projects-config.json')) {
            projectConfigs = JSON.parse(fs.readFileSync('config/projects-config.json', 'utf8'));
            console.log('Loaded custom project configurations');
          }
        } catch (error) {
          console.warn('Could not load projects-config.json:', error.message);
        }
        
        // Process repositories
        const processed = filtered.map(repo => {
          // Check for custom configuration
          const configKey = repo.name; // Use original repo name as key
          const customConfig = projectConfigs[configKey] || {};
          
          // Use custom name if available, otherwise format the repo name
          const projectName = customConfig.name || formatProjectName(repo.name);
          
          // Use custom description if available, otherwise use repo description or generate one
          let projectDescription;
          if (customConfig.description) {
            projectDescription = customConfig.description;
          } else if (repo.description && repo.description.length > 0) {
            projectDescription = repo.description;
          } else {
            const language = repo.language || 'Various technologies';
            projectDescription = `Built using ${language} and other modern technologies.`;
          }
          
          return {
            id: repo.id,
            name: projectName,
            description: projectDescription,
            language: repo.language || 'Various',
            topics: repo.topics || [],
            url: repo.html_url,
            private: repo.private,
            updatedAt: repo.updated_at,
            originalName: repo.name  // Store original repo name for config matching
          };
        });
        
        // Sort by updated date (most recent first)
        processed.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
        
        // Write to projects.json
        fs.writeFileSync('projects.json', JSON.stringify(processed, null, 2));
        console.log(`Generated projects.json with ${processed.length} projects`);
        EOF
    
    - name: Commit and push projects.json
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add projects.json
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "No changes to commit. projects.json is up to date."
        else
          git commit -m "Update projects data [skip ci]"
          git push
          echo "Successfully updated projects.json"
        fi

