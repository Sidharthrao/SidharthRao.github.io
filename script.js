// Configuration from config.js (optional, only for local testing)
let config = {
    excludeForks: true,
    excludeArchived: true,
    excludePrivate: false
};

// Initialize configuration (optional)
if (typeof window.config !== 'undefined') {
    config = { ...config, ...window.config };
}

// Project custom configurations (loaded from config/projects-config.json)
let projectConfigs = {};

// Load custom project configurations
async function loadProjectConfigs() {
    try {
        const response = await fetch('config/projects-config.json');
        if (response.ok) {
            projectConfigs = await response.json();
            console.log('Loaded custom project configurations');
        }
    } catch (error) {
        console.warn('Could not load projects-config.json:', error);
        // Config file is optional, continue without it
    }
}

// Load projects from JSON file (generated by GitHub Actions)
async function loadProjectsFromJSON() {
    try {
        // Add cache-busting query parameter to force fresh fetch
        const cacheBuster = new Date().getTime();
        const response = await fetch(`projects.json?v=${cacheBuster}`, {
            cache: 'no-cache'
        });
        if (!response.ok) {
            throw new Error('projects.json not found');
        }
        const projects = await response.json();
        return projects;
    } catch (error) {
        console.warn('Could not load projects.json:', error);
        return null;
    }
}

// Fallback: GitHub API Functions (for local testing only)
const GITHUB_API_BASE = 'https://api.github.com';

async function fetchRepositoriesFromAPI() {
    const url = `${GITHUB_API_BASE}/user/repos?type=all&per_page=100&sort=updated&direction=desc`;
    const headers = {
        'Accept': 'application/vnd.github.v3+json'
    };

    if (config.githubToken) {
        headers['Authorization'] = `token ${config.githubToken}`;
    }

    try {
        const response = await fetch(url, { headers });
        
        if (!response.ok) {
            if (response.status === 401) {
                throw new Error('Authentication failed. Please check your GitHub token.');
            }
            throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
        }

        const repos = await response.json();
        return repos;
    } catch (error) {
        console.error('Error fetching repositories:', error);
        throw error;
    }
}

// Data Processing Functions (for local testing fallback)
function filterRepositories(repos) {
    // Get exclusion list from config, default to empty array
    const excludeRepos = config.excludeRepos || [];
    
    return repos.filter(repo => {
        if (config.excludeForks && repo.fork) return false;
        if (config.excludeArchived && repo.archived) return false;
        if (config.excludePrivate && repo.private) return false;
        // Exclude specific repositories by name (case-insensitive)
        if (excludeRepos.some(excluded => repo.name.toLowerCase() === excluded.toLowerCase())) {
            return false;
        }
        return true;
    });
}

function formatDate(dateString) {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    const options = { year: 'numeric', month: 'long', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
}

function getDateRange(createdAt, updatedAt) {
    if (!createdAt) return 'Date not available';
    
    const created = new Date(createdAt);
    const updated = new Date(updatedAt);
    
    const createdFormatted = created.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
    
    // If updated is significantly different from created, show range
    const daysDiff = Math.floor((updated - created) / (1000 * 60 * 60 * 24));
    
    if (daysDiff > 30) {
        const updatedFormatted = updated.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
        return `${createdFormatted} - ${updatedFormatted}`;
    }
    
    return `Started ${createdFormatted}`;
}

function createBusinessDescription(repo) {
    // Use existing description if it's business-friendly
    if (repo.description && repo.description.length > 0) {
        // Check if description seems technical (contains common tech terms)
        const technicalTerms = ['api', 'framework', 'library', 'npm', 'package', 'module', 'component', 'hook', 'utils'];
        const descriptionLower = repo.description.toLowerCase();
        const isTechnical = technicalTerms.some(term => descriptionLower.includes(term));
        
        if (!isTechnical || repo.description.length < 50) {
            return repo.description;
        }
    }
    
    // Generate business-friendly description
    const language = repo.language || 'Various technologies';
    const topics = repo.topics || [];
    
    let description = `A ${repo.private ? 'private' : 'public'} project`;
    
    if (topics.length > 0) {
        const businessTopics = topics.filter(topic => 
            !['javascript', 'typescript', 'python', 'java', 'react', 'node', 'api'].includes(topic.toLowerCase())
        );
        if (businessTopics.length > 0) {
            description += ` focused on ${businessTopics.slice(0, 2).join(' and ')}`;
        }
    }
    
    description += `. Built using ${language} and other modern technologies.`;
    
    return description;
}

function processRepository(repo) {
    // Check for custom configuration (use original repo name as key)
    const configKey = repo.name;
    const customConfig = projectConfigs[configKey] || {};
    
    // Use custom name if available, otherwise format the repo name
    const projectName = customConfig.name || formatProjectName(repo.name);
    
    // Use custom description if available, otherwise use repo description or generate one
    let projectDescription;
    if (customConfig.description) {
        projectDescription = customConfig.description;
    } else if (repo.description && repo.description.length > 0) {
        projectDescription = repo.description;
    } else {
        const language = repo.language || 'Various technologies';
        projectDescription = `Built using ${language} and other modern technologies.`;
    }
    
    // Extract technologies from config, description, or use language as fallback
    let technologies = [];
    if (customConfig.technologies && Array.isArray(customConfig.technologies)) {
        technologies = customConfig.technologies;
    } else if (repo.technologies && Array.isArray(repo.technologies)) {
        technologies = repo.technologies;
    } else {
        // Extract from description
        technologies = extractTechnologies(projectDescription);
        // Clean description to remove technologies section
        projectDescription = cleanDescription(projectDescription);
    }
    
    // If no technologies found, use language as fallback
    if (technologies.length === 0 && repo.language) {
        technologies = [repo.language];
    }
    
    return {
        id: repo.id,
        name: projectName,
        description: projectDescription,
        language: repo.language || 'Various',
        topics: repo.topics || [],
        technologies: technologies,
        url: repo.html_url,
        private: repo.private,
        updatedAt: repo.updated_at,
        originalName: repo.name  // Store original repo name for config matching
    };
}

function formatProjectName(name) {
    // Convert kebab-case or snake_case to Title Case
    return name
        .split(/[-_]/)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

// Extract technologies from description text
function extractTechnologies(description) {
    if (!description) return [];
    
    // Look for "Technologies: ..." pattern (match until period or end of string)
    const techMatch = description.match(/Technologies:\s*([^.]*?)(?:\.|$)/i);
    if (techMatch && techMatch[1]) {
        // Split by comma and clean up each technology
        const techs = techMatch[1]
            .split(',')
            .map(tech => tech.trim())
            .filter(tech => tech.length > 0);
        return techs;
    }
    
    return [];
}

// Remove technologies section from description
function cleanDescription(description) {
    if (!description) return description;
    // Remove "Technologies: ..." part from description (match until period or end of string)
    return description.replace(/\s*Technologies:\s*[^.]*?\.?\s*/i, '').trim();
}

// Client-side filter to ensure excluded repos don't show (safety check)
function filterExcludedProjects(projects) {
    const excludeRepos = config.excludeRepos || [];
    if (excludeRepos.length === 0) return projects;
    
    return projects.filter(project => {
        // Check both the formatted name and try to match against exclusion list
        const projectNameLower = project.name.toLowerCase();
        const isExcluded = excludeRepos.some(excluded => {
            const excludedLower = excluded.toLowerCase();
            // Check exact match or if excluded name appears in project name
            return projectNameLower === excludedLower || 
                   projectNameLower.includes(excludedLower) ||
                   excludedLower.includes(projectNameLower);
        });
        return !isExcluded;
    });
}

// Rendering Functions
function renderProjects(projects) {
    const container = document.getElementById('projects-container');
    const loading = document.getElementById('loading');
    const error = document.getElementById('error');
    
    loading.style.display = 'none';
    error.style.display = 'none';
    
    if (!projects || projects.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 40px;">No projects found.</p>';
        return;
    }
    
    // Apply client-side exclusion filter (safety check)
    projects = filterExcludedProjects(projects);
    
    // Sort projects by updated date (most recent first)
    projects.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
    
    container.innerHTML = projects.map(project => createProjectCard(project)).join('');
}

function createProjectCard(project) {
    // Create technology stack bubbles (blue bubbles)
    const technologies = project.technologies || [];
    
    // Debug logging (remove after testing)
    if (project.name === 'Financial Anomaly Detection System') {
        console.log('Project:', project.name);
        console.log('Technologies:', technologies);
        console.log('Description:', project.description);
    }
    
    const technologyBubbles = technologies.map(tech => 
        `<span class="tech-bubble">${escapeHtml(tech)}</span>`
    ).join('');
    
    const technologySection = technologies.length > 0 
        ? `<div class="project-card__technologies">${technologyBubbles}</div>`
        : '';
    
    // For private repos, show "Private Repo" text instead of GitHub link
    // For public repos, show GitHub link
    const linkSection = project.private 
        ? '<div class="project-card__link"><span class="private-repo-label">Private Repo</span></div>'
        : project.url 
            ? `<div class="project-card__link"><a href="${project.url}" target="_blank" rel="noopener noreferrer">View on GitHub â†’</a></div>`
            : '';
    
    return `
        <div class="project-card">
            <h2 class="project-card__title">${escapeHtml(project.name)}</h2>
            <p class="project-card__description">${escapeHtml(project.description)}</p>
            ${technologySection}
            ${linkSection}
        </div>
    `;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showError(message) {
    const loading = document.getElementById('loading');
    const error = document.getElementById('error');
    
    loading.style.display = 'none';
    error.style.display = 'block';
    error.querySelector('p').textContent = message;
}

// Initialize
async function init() {
    // Set current year in footer
    document.getElementById('current-year').textContent = new Date().getFullYear();
    
    // Load custom project configurations first
    await loadProjectConfigs();
    
    try {
        // Try to load from projects.json first (generated by GitHub Actions)
        let projects = await loadProjectsFromJSON();
        
        if (!projects) {
            // Fallback: Use GitHub API (for local testing only)
            console.log('Loading from GitHub API (local testing mode)...');
            if (!config.githubToken) {
                showError('Projects data not available. The GitHub Actions workflow should generate projects.json automatically. For local testing, configure your token in config.js');
                return;
            }
            const repos = await fetchRepositoriesFromAPI();
            const filteredRepos = filterRepositories(repos);
            projects = filteredRepos.map(processRepository);
        } else {
            // Apply custom configurations to projects loaded from JSON
            projects = projects.map(project => {
                // Try to find config key using originalName if available, or match by URL
                let configKey = null;
                
                // First try using originalName if it exists (from workflow)
                if (project.originalName && projectConfigs[project.originalName]) {
                    configKey = project.originalName;
                } else {
                    // Try to match by URL (extract repo name from GitHub URL)
                    if (project.url) {
                        const urlMatch = project.url.match(/github\.com\/[^\/]+\/([^\/]+)/);
                        if (urlMatch && urlMatch[1]) {
                            const repoNameFromUrl = urlMatch[1];
                            if (projectConfigs[repoNameFromUrl]) {
                                configKey = repoNameFromUrl;
                            }
                        }
                    }
                    
                    // Fallback: try matching formatted names
                    if (!configKey) {
                        for (const [key, value] of Object.entries(projectConfigs)) {
                            if (formatProjectName(key).toLowerCase() === project.name.toLowerCase()) {
                                configKey = key;
                                break;
                            }
                        }
                    }
                }
                
                const customConfig = configKey ? projectConfigs[configKey] : {};
                
                // Extract technologies from config or existing project data
                let technologies = [];
                if (customConfig.technologies && Array.isArray(customConfig.technologies)) {
                    technologies = customConfig.technologies;
                } else if (project.technologies && Array.isArray(project.technologies)) {
                    technologies = project.technologies;
                } else {
                    // Extract from description
                    const description = customConfig.description || project.description || '';
                    technologies = extractTechnologies(description);
                }
                
                // Clean description if technologies were extracted from it
                let description = customConfig.description || project.description || '';
                if (technologies.length > 0 && !customConfig.technologies && !project.technologies) {
                    description = cleanDescription(description);
                }
                
                // Fallback to language if no technologies found
                if (technologies.length === 0 && project.language) {
                    technologies = [project.language];
                }
                
                return {
                    ...project,
                    name: customConfig.name || project.name,
                    description: description,
                    technologies: technologies
                };
            });
        }
        
        renderProjects(projects);
    } catch (error) {
        console.error('Initialization error:', error);
        showError(error.message || 'Failed to load projects. Please check your configuration and try again.');
    }
}

// Run when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

